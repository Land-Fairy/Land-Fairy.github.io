---
title: 反射
date: 2019-09-03 20:18:02
categories: Java
---

> Java 中反射的概念

<!-- more -->

### 1. 类的加载&连接&初始化

#### 1.1 JVM 和 类

​	调用 Java命令执行Java程序 => 启动一个Java虚拟机进程

> 不管该Java程序有多复杂，其中有多少个线程，他们都处于该 虚拟机进程中

> 同一JVM的所有进程，所有变量都处于同一个进程中，都使用该 JVM进程的内存

> 不同的程序 位于 不同的 JVM 虚拟机进程中，互不干扰

- 疑问

  同一Java程序只能是多线程， 而非多进程？

#### 1.2 类的加载

- Class 类

> 1. 由于事物有一些特征，可以抽取其特点 => 即为类
> 2. 那么类也有一些特征，比如具有 构造方法，有成员变量，有方法等等 => 抽象类的类 (用来描述类的)

> 每个类都是一批具有相同特征的对象的抽象，而系统中所有类其实也是一个实例，都是 java.lang.Class的实例

> 每个 java.lang.Class 都对应一类 类（因为该类型类具有统一特点)

##### 1. 类加载

> 将类的 class 文件 读入内存 =》 创建一个 java.lang.Class对象

- 类加载器

> 类的加载是由 类加载器 来完成的，通常由 JVM来提供

##### 2. 类的连接

> 生成 Class对象后，会进入连接阶段，该阶段负责把 二进制数据合并到 JRE中，类的连接又有3个阶段

1. 验证阶段: 检验被加载的类是否有正确的内部结构
2. 准备阶段: 负责为类的变量分配内存，并设置默认值
3. 解析阶段: 将累的二进制数据中的符号引用替换为直接引用

##### 3. 类的初始化

> 该阶段 只要是对类变量 进行初始化

- Java 中类变量初始值方法

> 声明变量时，指定初始值

![reflect001](E:\07_blog\source\_posts\反射\reflect001.png)

### 2. 获取 Class 对象

- 使用全类名

> 将字节码文件加载进内存中，返回Class对象

> 多用于配置文件，将类名定义在配置文件中，读取文件，然后加载类

```
Class.forName("全类名")
```

- 使用 类名

> 通过类名的 class 属性 来获取 Class 对象 （推荐使用，由于是属性，速度最快)

```
类名.class
```

- getClass()方法

> 通过 类实例的 getClass()方法来获取

```
person.getClass()
```

#### 测试

> 三种方式获取到的Class 都是同一个对象(一个类字节码文件，对应一个Class对象)

```java
 public static void main(String[] args) throws ClassNotFoundException {
        //1. 全类名的方式
        Class cls1 = Class.forName("com.day.domain.Person");

        //2. 使用类名.class 方式
        Class cls2 = Person.class;

        //3. getClass() 方式
        Person p = new Person();
        Class cls3 = p.getClass();

        // 比较三个对象 
        System.out.println(cls1 == cls2); // true
        System.out.println(cls2 == cls3); // true
    }
```

### 3. Class对象功能

#### 3.1 获取成员变量

```java
Field getField​(String name);
Field[] getFields();

Field getDeclaredField​(String name);
Field[] getDeclaredFields();
```

- getFields

> 只能获取 public 的 成员变量

```java
 Class personCls = Person.class;
 /*
 * 获取成员变量
 * */
 Field[] fields = personCls.getFields();
 for(Field field: fields){
 	System.out.println(field); 
 }
// 结果:（发现只有public的成员变量)
public java.lang.String com.day.domain.Person.name
```

- getField(String name)

> 用来获取 指定字段名称的 成员变量， 可能会有 NoSuchFieldException 异常

> 获取到的 Field 类，还可以对 该成员变量进行设置值 
>
> get(obj): 获取 obj 这个对象 的 对应成员变量的值, 可能会有 IllegalAccessException 异常
>
> set(obj, value)： 给obj 这个对象的 该成员变量设置值为 value

```java
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        Class personCls = Person.class;

        Person p = new Person();
        p.setName("aaa");
        /*
        * 获取成员变量
        * */
        Field name = personCls.getField("name");

        /* 获取成员变量的值 */
        Object obj = name.get(p);
        System.out.println(obj);

        /* 设置成员变量的值 */
        name.set(p, "bbbb");
        System.out.println(p);
    }
// 打印结果
aaa
Person{name='bbbb', age=0}
```

- getDeclaredFields

> 用来获取所有的成员变量，包括 私有

> 可直接访问、设置 私有成员变量

> age.setAccessible(true); 可以设置 age 这个私有成员变量可访问，否则会有 IllegalAccessException 异常

```java
public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        Class personCls = Person.class;

        Person p = new Person();
        p.setName("aaa");
        p.setAge(100);
        /* 获取 所有成员变量 */
        Field[] declaredFields = personCls.getDeclaredFields();
        for(Field field: declaredFields) {
            System.out.println(field);
        }

        /* 获取 age 成员变量 */
        Field age = personCls.getDeclaredField("age");

        /* 设置 私有成员变量可访问 */
        age.setAccessible(true);
        /* 获取 成员变量值 */
        Object ageV = age.get(p);
        System.out.println(ageV);

        age.set(p, 100);
        System.out.println(p);
    }
// 打印结果
public java.lang.String com.day.domain.Person.name
private int com.day.domain.Person.age
100
Person{name='aaa', age=100}
```

#### 3.2 获取 构造方法

```java
Constructor<T> getConstructor​(Class<?>... parameterTypes);
Constructor<?>[] getConstructors();
```

> getConstructor(Class): 可以获取对应 参数的 构造函数

> 可以使用 构造函数对象的 newInstance 来创建新的对象

> 如果调用空参的构造函数，可以直接使用 Class.newInstance() 来创建对象

```java
public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class personCls = Person.class;

        /* 获取只有一个 string 类型的 构造函数*/
        Constructor constructor = personCls.getConstructor(String.class);

        Object p = constructor.newInstance("aaa");
        System.out.println(p);

    }
// 打印
Person{name='aaa', age=0}
```

#### 3.3 获取 方法

```java
Method getMethod​(String name, Class<?>... parameterTypes);
Method[] getMethods();
```

> 使用 getMethod("eat", String.class) 来获取 参数类型为 string，方法名为 eat 的方法

> 可以使用 invoke 来对方法进行调用

> 对于 private 方法，也可以使用 setAccessible 设置

```java
public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class personCls = Person.class;

        Person p = new Person();
        /* 获取参数为 string 的 eat 方法 */
        Method eat = personCls.getMethod("eat", String.class);
        /* 调用eat 方法 */
        Object res = eat.invoke(p, "苹果");
        /* 由于返回值为void，因此res 为 null*/
        System.out.println(res);
    }
```

#### 3.4 获取注解

### 4. 案例

- 需求

1. properties 配置文件中配置有 全类名 和需要执行的方法
2. 利用反射的方式加载 配置文件中的 类，并执行该类的方法

- 实现

> properties 文件放在 src 目录下 （即 classpath下)

```java
// properties  文件的内容
className=com.day.domain.Person
methodName=eat
```

> 实现类

> 使用 calssLoader 来加载 配置文件

> Properties 的使用
>
> pClass.getDeclaredConstructor().newInstance() 来替代 已废弃的 Class.newInstance()方法

```java
public class Reflect {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        /* 加载配置文件
        * 1. 首先获取加载该类字节码文件的 classLoader
        * 2. 既然calssLoader 可以找到 该类的字节码，那么肯定也可以找到同在 classpath下的配置文件
        * 3. 使用 calssLoader 的方法 获取配置文件的位置/或者直接加载其为流
        * */
        ClassLoader classLoader = Reflect.class.getClassLoader();
        InputStream resourceAsStream = classLoader.getResourceAsStream("pro.properties");
        /* 创建 Properties 对象，并加载配置文件的流对象并解析*/
        Properties pro = new Properties();
        pro.load(resourceAsStream);
        /* 获取属性值 */
        String className = pro.getProperty("className");
        String methodName = pro.getProperty("methodName");
        /* 获取 Class对象*/
        Class pClass = Class.forName(className);
        /* 创建对象 */
        Object obj = pClass.getDeclaredConstructor().newInstance();

        /* 获取方法 */
        Method method = pClass.getMethod(methodName);
        method.invoke(obj);
    }
}
```



