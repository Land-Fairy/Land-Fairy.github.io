---
title: 多线程
date: 2019-08-30 00:36:40
categories: Java
---

>  JAVA 多线程

<!-- more-->

### 1. 创建线程

#### 方式一： 继承 Thread 类

- 继承Thread 类
- 复写 Thread类的 run 方法

> Thread 类中的run方法，可以理解为 用来存储 线程要执行的代码（即 给线程指定那些代码进行执行)

- 创建 Thread 类对象
- 执行 start 方法

> start 方法 用于开启一个线程，然后会调用 其中的  run方法
>
> 如果不调用 start 方法，直接执行 run方法，则结果是 在原线程中 执行了 run方法，没有达到新线程的效果

#### 方式二: 实现 Runable 接口

> 优点： 避免了 单继承。只需要实现 Runable 接口，即可 （推荐使用该类方式)

-  定义一个类，并实现 Runable 接口
- 覆盖 Runable 接口中的 run 方法

> 该方法存放 需要在 线程中执行的代码

- 通过 Thread 类建立线程对象，并将 实现 Runable接口的类 作为参数传入

> 将 Runable 接口的子类对象 作为 参数 传入 Thread 的构造函数原因是：需要让线程去指定 指定对象的run方法，就必须传入该对象

- 调用 Thrad类对象的 start 方法

### 2. 线程同步

#### 2.1 同步代码块

> 使用 obj 对象作为锁

```java
synchronized ( obj) 
{

}
```

#### 2.2 同步方法

> 该方式使用的锁是  this

```java
public synchronized void show()
{
	// code
}
```

#### 2.3 静态同步方法

> 使用的锁为  该类所属的字节码对象， 即 类名.class

```java
public static synchronized void show()
{
	// code
}
```

### 3. 单例模式

#### 3.1 饿汉模式

- 初始化时就创建好， 无线程问题

```java
class Single1
{
    private static  final  Single1 s = new Single1();
    public Single1 getInstance() {
        return s;
    }
}
```

#### 3.2 懒汉模式

- 延迟加载

> 1. 使用 对于 静态方法，使用 Single2.class 来作为锁
> 2. 两次判断，第一次用来提高性能

```java
class Single2
{
    private Single2 s = null;
    public static Single2 getInstance(){
        /* 提高性能， 类似于读锁*/
        if (s == null) {
            /* 同步*/
            synchronized (Single2.class)
            {
                /*判断必不可少*/
                if (s == null) {
                    s = new Single2();
                }
            }
        }
        return s;
    }
}
```

#### 3. 等待唤醒机制

### 4. lock condition

### 5. 守护线程

> 正常线程  ==> 前台线程
>
> 守护线程 ==> 后台线程
>
> 当所有的前台线程全部退出之后， 后台线程自动结束运行

