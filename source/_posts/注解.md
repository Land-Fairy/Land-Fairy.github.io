---
title: 注解
date: 2019-09-03 23:41:22
categories: Java
---

> Java 注解

<!-- more -->

### 1. 定义

> 也叫元数据，一种代码级别的说明

> 自 JDK1.5 之后引入，与类，接口，枚举等在同一个层次

> 可以声明在 包，类，方法，局部变量，方法参数 等的前面，用来对这些进行说明和注释

### 2. 作用

> 编写文档:通过代码里标识的注解来生成文档

> 代码分析: 通过代码里标识的注释对代码进行分析（使用反射)

> 编译检查: 通过标识的注释，让编译器实现基本检查（比如重写方法标注为 Override)

### 3. JDK中预定义的注解

- @Override

> 检测被该注解的方法，是否是继承自父类(父接口)的

- @Deprecated

> 该注解标注的内容已经被遗弃

- @SuppressWarnings（"all")

> 压制所有警告，一般传递参数 "all", 注解在类上，压制该类所有的警告

### 4. 自定义注解

#### 4.1 Override 注解的形式

```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

#### 4.2 自定义一个我们的注解

```java
package com.day.annocation;

public @interface MyAnno {
}
```

- 将只包含该注解的 java 文件编译为 class 文件

```java
javac MyAnno.java
```

- 反编译 刚生产的 .class 文件

```java
javap MyAnno.class
//得到的内容如下
    Compiled from "MyAnno.java"
    public interface com.day.annocation.MyAnno extends java.lang.annotation.Annotation {
	}
```

> 由此可知，注解本质上是一个 interface， 继承自 java.lang.annotation.Annotation

### 5. 注解的属性

接口中的抽象方法，称为 注解的属性， 要求如下:

- 属性的返回值类型

> 基本数据类型 (不包括 void )

> String

> 枚举类型

> 注解类型

> 以上类型的数组

```java
public @interface MyAnno {
    int show1();
    String show2();
    /* 枚举类型的返回值 */
    EnumPerson show3();
    /* 其他注解类型 */
    /* 类型数组 */
    String[] show4();
}
```

#### 注意:

> 定义了属性之后，需要在使用注解的时候，给其赋值

- default 默认值

> 如果属性使用了 default 指定默认值，则可以不赋值

- 特殊的 value 属性

> 使用时，需要给属性赋值，格式为 key=v, 但是如果只有一个属性需要赋值，并且该属性名为 value，则 赋值时可以只写值，value  省略。 比如: @MyAnno(1) 表示 value属性 的值是1

- 注解返回值属性的赋值

> 对于 注解形式的属性，赋值为: @MyAnno(anno=@MyAnno2) 

- 数组返回值属性的赋值

> 对于 数组形式的属性，其赋值为: @MyAnno(arr={"1", "2"})
>
> 并且，如果 arr 的值只有一个，{}可以省略，即为  @MyAnno(arr="1")

```java
// 注解的定义
public @interface MyAnno {
    int show1();
    String show2() default "aaaaa";
}

// 使用时，需要给无默认值的属性进行赋值
@MyAnno(show1 = 1)
public class Reflect {
}
```

### 6 . 元注解

> 描述注解的注解

- @Target

> 描述注解可以作用的位置

```java
/* ElementType 的取值
	TYPE: 作用于类
	METHOD: 作用于方法上
	FIELD: 作用于成员变量上
*/
@Target(value = {ElementType.TYPE})
public @interface MyAnno {
    int show1();
    String show2() default "aaaaa";
}
```



- @Retention

> 描述注解被保留的阶段

```java
/* RetentionPolicy 的取值:
	SOURCE: 源码阶段
    CLASS: Class 对象阶段
    RUNTIME: 运行时阶段， 一般都使用 RUNTIME，JVM可在运行时读取到该注解
*/	
@Target(value = {ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnno {
    int show1();
    String show2() default "aaaaa";
}
```

- @Documented

> 描述注解是否被抽取到 api 文档之中

使用javadoc 生成java 文档的时候，该注解可以在文档中显示

- @Inherited

> 描述注解是否可以被 子类继承

### 7. 程序中解析注解

#### 7.1 获取注解中属性的值

- 需求

反射时，可以通过配置文件方式配置 需要自动加载的 类 和方法，通过反射，直接调用 方法；

使用注解可以更加方便的替代 配置文件的工作

- 定义注解

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoRun {
    String className(); // 要生成对象的 全类名
    String methodName(); // 要调用的方法名
}
```

- 根据注解，获取 要加载的 类名和方法名

```java
@AutoRun(className = "com.day.domain.Person", methodName = "eat")
public class Reflect {

    public static void main(String[] args) {
        /* 获取 Class对象, 因为注解在该类上配置着*/
        Class pClass = Reflect.class;
        /* 获取 该类的对应名称的注解
        * 该语句在 内存中 生成了一个 该注解接口的子类对象，
        * 该对象复写了里面的2个抽象方法，因此可以用该对象调用抽象方法
        * 抽象方法返回的值，就是 在注解上 属性配置的值
        * */
        Annotation annotation = pClass.getAnnotation(AutoRun.class);
        if (annotation instanceof AutoRun) {
            /* Annotation 转 AutoRun*/
            AutoRun autoRun = (AutoRun)annotation;
            /* 调用 两个抽象方法，获取 注解配置的 值*/
            String className = autoRun.className();
            String methodName = autoRun.methodName();
            System.out.println(className); // 打印结果： com.day.domain.Person
            System.out.println(methodName); // 打印结果: eat
            /* == 根据获取到的 类名 和 方法名，使用反射 进行创建对象并调用 */
        }
    }
}

```

### 8. Demo（简单的测试框架)

####  需求

简单的测试一个类的 n 个方法 是否有异常，如果有异常，进行记录。

#### 思路

通过注解的方式，标识出需要测试的方法，使用反射查看方法上是否有特定注解，如果有，执行该方法，查看是否有异常，如果有，记录到文件中

#### 实现

- 定义一个 作用于method上，runtime时期的注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Check {
}
```

- 对需要测试的方法，添加注解

```java
package com.day.domain;

import com.day.annocation.Check;

public class Calucator {
    @Check
    public void add() {
        System.out.println(1 + 1);
    }
    @Check
    public void sub() {
        System.out.println(2 -1 );
    }
    @Check
    public void Multi() {
        System.out.println(2 *1 );
    }
    @Check
    public void Div(){
        System.out.println(1/0);
    }
}
```

- 编写测试类进行测试

```java
public class CalucatoTest {
    public static void main(String[] args) throws IOException {
        /* 1. 创建需要测试的类对象 */
        Calucator calucator = new Calucator();

        /* 2. 获取 对应的 class */
        Class aClass = calucator.getClass();

        /* 3. 获取 该Class 所有方法 */
        Method[] declaredMethods = aClass.getDeclaredMethods();

        BufferedWriter bw = new BufferedWriter(new FileWriter("bug.txt"));
        /* 4. 遍历所有方法 */
        for (Method m : declaredMethods) {
            /* 5. 判断该方法上，是否有 Check 注解*/
            boolean annotationPresent = m.isAnnotationPresent(Check.class);
            if (annotationPresent) {
                m.setAccessible(true);
                /* 6. 如果注解出现，执行 该方法 */
                try {
                    Object invoke = m.invoke(calucator);
                } catch (Exception e) {
                    /* 7. 打印错误日志到文件 */
                    bw.write("出现异常方法: " + m.getName());
                    bw.newLine();
                    bw.write("异常名称: " + e.getCause().getClass().getName());
                    bw.newLine();
                    bw.write("异常原因: " + e.getCause().getMessage() );
                }
            }

        }
        bw.flush();
        bw.close();
    }
}
```

- bug.txt 文件内容

```java
出现异常方法: Div
异常名称: java.lang.ArithmeticException
异常原因: / by zero
```

